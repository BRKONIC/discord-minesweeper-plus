<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Discord用マインスイーパー生成機プラス</title>
  <meta name="description" content="Discordサーバーで楽しめるマインスイーパーを簡単に生成できるWebツール。カスタム絵文字を使用して、より個性的なゲーム体験を提供します。">
  <meta name="keywords" content="Discord, Minesweeper, ディスコード, マインスイーパー, ゲーム, Discordツール, Discordゲーム生成, カスタム絵文字, プラス機能">
  <meta property="og:title" content="Discord用マインスイーパー生成機プラス" />
  <meta property="og:description" content="マインスイーパーをMarkdown形式で生成します。" />
  <meta property="og:image" content="https://brkonic.github.io/discord-minesweeper-plus/images/discord-minesweeper-plus-image.png" />
  <meta property="og:url" content="https://brkonic.github.io/discord-minesweeper-plus/" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Discord用マインスイーパー生成機プラス" />
  <meta name="twitter:description" content="マインスイーパーをMarkdown形式で生成します。" />
  <meta name="twitter:image" content="https://brkonic.github.io/discord-minesweeper-plus/images/discord-minesweeper-plus-image.png" /> 
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      scrollbar-gutter: stable;
    }

    body {
      font-family: Arial, sans-serif;
      background-color: #212121;
      color: #f1f1f1;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1, h2 {
      text-align: center;
      margin-bottom: 10px;
    }

    .mt-2 { margin-top: 20px; }
    .mb-1 { margin-bottom: 10px; }
    .mb-2 { margin-bottom: 20px; }
    
    .w-auto { width: auto !important; }

    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      width: 100%;
      max-width: 680px;
    }

    .controls label {
      display: flex;
      flex-direction: column;
      color: #ccc;
      width: 150px;
    }

    .checkbox-inline {
      display: flex;
      align-items: center;
      gap: 5px;
      color: #ccc;
    }

    input[type="text"], input[type="number"] {
      padding: 8px;
      margin-top: 5px;
      border: none;
      border-radius: 5px;
      background-color: #333;
      color: #f1f1f1;
    }

    button {
      padding: 10px 20px;
      margin: 5px;
      background-color: #333;
      color: #f1f1f1;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #555;
    }

    .radio-controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .radio-controls input[type="radio"] {
      display: none;
    }

    .radio-controls label {
      padding: 10px 20px;
      background-color: #333;
      color: #f1f1f1;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .radio-controls label:hover {
      background-color: #555;
    }

    .radio-controls input[type="radio"]:checked + label {
      background-color: #f1f1f1;
      color: #0f0f0f;
    }

    .accordion {
      width: 100%;
      margin-bottom: 10px;
      border-radius: 5px;
      box-shadow: 0 7px 15px -5px rgb(0 0 0 / 5%);
      background-color: #f1f1f1;
    }

    .accordion summary {
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
      padding: 10px 20px;
      color: #0f0f0f;
      cursor: pointer;
    }

    .accordion summary::-webkit-details-marker {
      display: none;
    }

    .accordion summary::after {
      transform: translateY(-25%) rotate(45deg);
      width: 7px;
      height: 7px;
      margin-left: 10px;
      border-bottom: 3px solid #333333b3;
      border-right: 3px solid #333333b3;
      content: '';
      transition: transform .3s;
    }

    .accordion[open] summary::after {
      transform: rotate(225deg);
    }

    .accordion .accordion-item {
      transform: translateY(-10px);
      opacity: 0;
      margin: 0;
      padding: 15px;
      transition: transform .5s, opacity .5s;
    }

    .accordion[open] .accordion-item {
      transform: none;
      opacity: 1;
    }

    textarea {
      width: 100%;
      max-width: 680px;
      padding: 10px 16px;
      background-color: #333;
      color: #f1f1f1;
      border: none;
      resize: none;
      margin-bottom: 20px;
    }

    .sub-text {
      color: #aaa;
      text-align: center;
    }
    .danger-text { color: #FF0033; }
    .notes-text { color: #fbc02d; }

    table {
      border-collapse: collapse;
      cursor: pointer;
      user-select: none;
      margin-top: 10px;
    }

    td {
      width: 30px;
      height: 30px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      text-align: center;
    }

    .spoiler {
      color: transparent;
    }
    
    .isReveal {
      color: #79dfc1 !important;
    }

    tr:not(.highlight-row) .spoiler:not(.highlight-col) {
      background-color: #444;
    }

    td.spoiler:hover {
      background-color: #616161;
    }

    .highlight-row, .highlight-col {
      background-color: #757575;
    }

    td:not(.spoiler) {
      background-color: #212121;
      cursor: auto;
    }

    td:not(.spoiler):hover {
      background-color: #212121;
    }

    .hide{
      display: none;
    }

    p.tgToolTip {
      margin: 0;
      padding: 0.5em 1em;
      background-color: #0d6efd;
      color: #f1f1f1;
      border-radius: 5px;
      border-color: #2a2e35 transparent transparent transparent;
      -moz-border-radius: 5px;
      min-height: 1em;
      top: 100px;
      left: 20px;
      position: absolute;
      z-index: 100;
    }

    p.tgToolTip::after {
      content: "";
      position: absolute;
      top: calc(100% - 1px);
      left: 50%;
      transform: translateX(-50%);
      border-width: 6px;
      border-style: solid;
      border-color: #0d6efd transparent transparent transparent;
    }

    .dummy {
      width: 100%;
      height: 100%;
      position: fixed;
      top: 0;
      left: 0;
      opacity: 0;
    }

    @media (max-width: 600px) {
      body {
        padding: 10px;
      }

      h1 {
        font-size: x-large;
      }

      h2 {
        font-size: larger;
      }

      .controls {
        flex-direction: column;
        align-items: stretch;
      }

      .controls label {
        width: 100%;
        align-items: flex-start;
      }

      input[type="text"], input[type="number"] {
        width: 100%;
        font-size: 16px;
      }

      button {
        width: 100%;
        font-size: 16px;
        margin: 0;
      }

      .radio-controls {
        flex-direction: column;
        gap: 5px;
      }

      .radio-controls label {
        width: 100%;
        text-align: center;
      }

      textarea {
        font-size: 14px;
      }

      td {
        width: 24px;
        height: 24px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <h1>Discord用マインスイーパー生成機プラス</h1>
  <p class="sub-text mb-2">マインスイーパーをMarkdown形式で生成します。<br/>生成結果をコピーしてDiscordにペーストしてください。</p>

  <div class="controls mb-1">
    <label>幅<input id="width" type="number" inputMode="numeric" class="validated-input-num" value="9" data-default="9" min="1" max="100" placeholder="ボードの幅"></label>
    <label>高さ<input id="height" type="number" inputMode="numeric" class="validated-input-num" value="9" data-default="9" min="1" max="100" placeholder="ボードの高さ"></label>
    <label>地雷数<input id="count" type="number" inputMode="numeric" class="validated-input-num" value="10" data-default="10" min="1" max="10000" placeholder="ボードの地雷数"></label>
    <label>地雷用絵文字<input id="emoji" type="text" value=":bomb:" maxlength="32" placeholder="地雷用絵文字の名前"></label>
  </div>
  
  <div class="controls mb-1">
    <div class="checkbox-inline">
      <input id="reveal-safe" type="checkbox" checked />
      <label for="reveal-safe" class="checkbox-inline w-auto">
        安全そうなマスを1つ公開する
      </label>
    </div>
  </div>
  
  <div class="controls mb-1">
    <button onclick="generate()">生成</button>
    <button onclick="copy(event)" class="tgTtip" data-tooltip="コピー完了！">コピー</button>
    <button onclick="inputClear()">クリア</button>
  </div>

  <div class="controls mb-1">
    <details class="accordion">
      <summary>生成結果を表示</summary>
      <textarea id="output" class="accordion-item" rows="10" placeholder="生成結果" readonly></textarea>
    </details>
  </div>

  <p>生成文字数: <span id="character-count">0</span>文字</p>
  <p class="notes-text mb-2">※Discordは2000文字まで</p>

  <h2>お試し</h2>
  <div class="radio-controls mb-1">
    <input type="radio" id="spoiler" name="spoiler" onclick="spoilerAll()" checked>
    <label for="spoiler">すべてスポイラー</label>
    <input type="radio" id="reveal" name="spoiler" onclick="revealAll()">
    <label for="reveal">スポイラー解除</label>
  </div>

  <table id="try-board"></table>

  <script>
    document.querySelectorAll('.validated-input-num').forEach(input => {
      input.addEventListener('input', () => validateInputValue(input));
      input.addEventListener('blur', () => validateInputValue(input));
    });

    document.addEventListener('DOMContentLoaded', function() {
      document.body.addEventListener('click', function(e) {
        if (e.target.classList.contains('dummy')) {
          removeToolTip();
        }
      });
    });

  function validateInputValue(input) {
    const max = parseInt(input.max, 10);
    const min = parseInt(input.min, 10);
    const defaultValue = parseInt(input.dataset.default, 10);
    let value = parseInt(input.value, 10);

    if (isNaN(value)) {
      input.value = defaultValue;
    } else if (value > max) {
      input.value = max;
    } else if (value < min) {
      input.value = min;
    }
  }

    function getRandomInt(max) {
      return Math.floor(Math.random() * max);
    }

    function generate() {
      const output = document.getElementById("output");
      const countDisplay = document.getElementById("character-count");
      const tryBoard = document.getElementById("try-board");
      const width = parseInt(document.getElementById("width").value);
      const height = parseInt(document.getElementById("height").value);
      let count = parseInt(document.getElementById("count").value);
      const emoji = document.getElementById("emoji").value;
      const spoiler = document.getElementById("spoiler").checked;
      const revealOne = document.getElementById("reveal-safe").checked;

      if (count > (width - 1) * (height - 1)) {
        count = (width - 1) * (height - 1);
      }

      const board = Array.from({ length: height }, () => Array(width).fill(0));
      while (tryBoard.rows.length) tryBoard.deleteRow(0);

      let placed = 0;
      while (placed < count) {
        const r = getRandomInt(height);
        const c = getRandomInt(width);
        if (board[r][c] < 0) continue;
        board[r][c] = -10000;
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            const nr = r + dr, nc = c + dc;
            if (nr >= 0 && nr < height && nc >= 0 && nc < width && board[nr][nc] >= 0) {
              board[nr][nc]++;
            }
          }
        }
        placed++;
      }

      const safeCells = [];
      for (let r = 0; r < height; r++) {
        for (let c = 0; c < width; c++) {
          if (board[r][c] === 0) safeCells.push({ r, c });
        }
      }
      const revealCell = revealOne && safeCells.length > 0 ? safeCells[getRandomInt(safeCells.length)] : null;

      let text = "";
      const emojiMap = [":zero:", ":one:", ":two:", ":three:", ":four:", ":five:", ":six:", ":seven:", ":eight:"];
      for (let r = 0; r < height; r++) {
        const tr = tryBoard.insertRow();
        for (let c = 0; c < width; c++) {
          const td = tr.insertCell();
          const isReveal = revealCell && revealCell.r === r && revealCell.c === c;

          if (spoiler && !isReveal) td.classList.add("spoiler");
          if (isReveal) td.classList.add("isReveal");

          if (board[r][c] < 0) {
            td.textContent = "x";
            td.classList.add("danger-text");
            text += !isReveal ? `||${emoji}||` : emoji;
          } else {
            td.textContent = isReveal? "●" : board[r][c] || "";
            const mark = emojiMap[board[r][c]] || ":zero:";
            text += !isReveal ? `||${mark}||` : mark;
          }
        }
        text += "\n";
      }

      output.value = text;
      countDisplay.textContent = text.length;
      countDisplay.classList.toggle("danger-text", text.length > 2000);
    }

    function copy(event) {
      const output = document.getElementById("output");
      output.select();
      navigator.clipboard.writeText(output.value).then(() => {
        showToolTip(event);
      }).catch(err => {
        alert('コピーに失敗しました: ' + err);
      });
    }

    function showToolTip(event){
      const target = event.target;
      if (!target.classList.contains("tgTtip")) {
        return;
      }

      const dataTooltip = target.getAttribute('data-tooltip');

      const tooltip = document.createElement('p');
      tooltip.className = 'tgToolTip';
      tooltip.textContent = dataTooltip;
      document.body.appendChild(tooltip);

      const rect = target.getBoundingClientRect();
      const buttonWidth = rect.width;
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

      const tooltipWidth = tooltip.offsetWidth;
      const tooltipHeight = tooltip.offsetHeight;

      const newPositionTop = rect.top + scrollTop - tooltipHeight - 8;
      const newPositionLeft = rect.left + scrollLeft + (buttonWidth / 2) - (tooltipWidth / 2);

      tooltip.style.top = newPositionTop + 'px';
      tooltip.style.left = newPositionLeft + 'px';

      const dummy = document.createElement('p');
      dummy.className = 'dummy';
      document.body.appendChild(dummy);

      setTimeout(() => {
          removeToolTip();
        }, 2000);
    }

    function removeToolTip(){
      var tooltip = document.querySelector('p.tgToolTip');
      var dummy = document.querySelector('p.dummy');
      if (tooltip) tooltip.remove();
      if (dummy) dummy.remove();
    }

    function inputClear() {
      document.getElementById("width").value = 9;
      document.getElementById("height").value = 9;
      document.getElementById("count").value = 10;
      document.getElementById("emoji").value = ":bomb:";
      document.getElementById("output").value = "";
      document.getElementById("reveal-safe").checked = true;
    }

    function revealAll() {
      document.querySelectorAll("#try-board td").forEach(td => td.classList.remove("spoiler"));
    }

    function spoilerAll() {
      document.querySelectorAll("#try-board td").forEach(td => {
        if (!td.classList.contains("isReveal")) {
          td.classList.add("spoiler");
        }
      });
    }

    document.getElementById("try-board").addEventListener("click", (e) => {
      if (e.target.tagName === "TD") {
        e.target.classList.remove("spoiler");
      }
    });

    document.getElementById("try-board").addEventListener("mouseover", (e) => {
      if (e.target.tagName === "TD") {
        const row = e.target.parentElement;
        row.classList.add("highlight-row");

        const index = [...e.target.parentElement.children].indexOf(e.target);
        document.querySelectorAll("#try-board tr").forEach(tr => {
          if (tr.children[index]) {
            tr.children[index].classList.add("highlight-col");
          }
        });
      }
    });

    document.getElementById("try-board").addEventListener("mouseout", (e) => {
      if (e.target.tagName === "TD") {
        const row = e.target.parentElement;
        row.classList.remove("highlight-row");

        const index = [...e.target.parentElement.children].indexOf(e.target);
        document.querySelectorAll("#try-board tr").forEach(tr => {
          if (tr.children[index]) {
            tr.children[index].classList.remove("highlight-col");
          }
        });
      }
    });

    generate();
  </script>
</body>
</html>
